# Тестовое задание: Загрузка и обработка файлов

## Описание:

Разработано приложение на Django, DRF, который позволяет загружать файлы на сервер, а затем асинхронно обрабатывать их с использованием Celery + Redis.
Приложение имеет два эндпоинта:
1. `api/upload/` - принимает POST-запросы для загрузки файлов. Во время загрузки запускается асинхронная Celery задача, которая обрабатывает файл;
2. `api/files/` - принимает GET-запросы и возвращает список всех файлов с их данными, включая статус обработки.

### Вопросы к тестовому заданию:

1. Опишите, как изменится архитектура, если мы ожидаем большую нагрузку:
 - Разместить приложение на нескольких серверах или использовать облачные ресурсы для распределения нагрузки;
 - Использовать кэширования, чтобы уменьшить нагрузку на базу данных и повысить производительность;
 - Разделить функциональность приложения на микросервисы, что облегчит масштабирование отдельных компонентов;
 - Масштабировать Redis и Celery. Запускать несколько экземпляров, чтобы обработка задач происходила параллельно;
 - В данный момент используется брокер сообщений Redis. Для более нагруженных систем можно использовать RabbitMQ. У данного брокера есть возможность выбора приоритета выполнения задач, также он лучше работает с микросервисной архитектурой.

2. Попробуйте оценить, какую нагрузку в RPS сможет выдержать ваш сервис:
 - Число RPS может сильно варьироваться в зависимости от ряда факторов, настройки приложения и сервера. Обычно небольшие проекты могут справляться с нагрузкой в диапазоне от нескольких сотен до нескольких тысяч запросов в секунду.

### Проект упакован в Docker-контейнеры:

- Контейнер для Redis.
- Контейнер для воркера Celery.
- Контейнер для Backend.
- Контейнер для базы данных Postgres.

## Технологии проекта:

- Python 3.11
- Django 4.2.7
- Django Rest Framework 3.14.0
- Celery 5.3.5
- Psycopg2 binary 2.9.9
- Redis 5.0.1

## Запуск приложения в Docker-контейнерах:

Для запуска приложения в контейнерах необходимо:

1. Клонировать репозиторий и перейти в директорию с файлом *docker-compose.yaml*:  
```
git clone git@github.com:alekseikoznov/file-loader.git
```
```
cd file-loader/
```

2. Создать файл .env с переменными окружения c помощью .env.example. Пример наполнения:
```
DB_NAME=postgres
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
DB_HOST=db
DB_PORT=5432
```

3. Открыть терминал и запустить docker-compose с ключом `-d`:
```
docker compose up -d
```

4. Выполнить миграции:
```
docker compose exec backend python src/manage.py migrate
```

5. Создать суперюзера:
```
docker compose exec backend python src/manage.py createsuperuser
```

6. Собрать статику:
```
docker compose exec backend python src/manage.py collectstatic --no-input
```

7. После успешного запуска проект станет доступен по адресу:  
http://localhost:8000/

8. Остановить проект:
```
docker compose down
```
